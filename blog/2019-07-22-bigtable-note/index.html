<!doctype html><html lang=zh-cn><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-143445286-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-143445286-1');</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Bigtable 是一个分布式存储系统，用于管理超大规模的结构化数据"><meta name=keywords content="Distributed System,LSM-Tree,Column storage,Google"><meta name=generator content="Hugo 0.59.1"><title>baishen | blog | Big Table笔记</title><link rel=stylesheet href=https://baishen.me/css/style.css><link rel=stylesheet href=https://baishen.me/css/syntax.css></head><body class="has-navbar-fixed-top page"><nav class="navbar is-fixed-top is-black"><div class=container><div class=navbar-brand><a class=navbar-item href=https://baishen.me/>baishen</a><div role=button class=navbar-burger aria-label=menu aria-expanded=false><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></div></div><div class=navbar-menu><div class=navbar-start><div class=navbar-item></div></div><div class=navbar-end><div class="navbar-item has-dropdown is-hoverable"><a class=navbar-link href=https://baishen.me/rust-note/>Rust Note</a><div class="navbar-dropdown is-hidden-touch"><a class=navbar-item href=https://baishen.me/rust-note/><strong>1</strong>. Introduction</a></div></div><div class=navbar-item><div class="field is-grouped"><p class=control><a class="button is-twitter-blue" target=_blank href=https://twitter.com/b41sh><span class="icon has-text-white"><i class="fab fa-twitter"></i></span><span>Twitter</span></a>
<a class="button is-inverted" target=_blank href=https://github.com/b41sh><span class=icon><i class="fab fa-github"></i></span><span>Github</span></a></p></div></div></div></div></div></nav><main class=main><section class="hero is-light"><div class=hero-body><div class=container><h1 class="title is-size-1 is-size-2-mobile has-text-black has-text-black-light">Big Table笔记</h1><p class="is-size-5 has-text-black-ter">2019-07-22</p><br></div></div></section><section class="section has-background-white"><div class=container><div class="content is-medium is-blog-content"><p>Bigtable 是一个分布式存储系统，用于管理超大规模的结构化数据</p><blockquote><p>Bigtable is a distributed storage system for managing structured data that is designed
to scale to a very large size: petabytes of data across thousands of commodity servers</p></blockquote><h2 id=1-介绍-introduction>1 介绍(Introduction)</h2><ul><li>PB级数据</li><li>数千台机器</li><li>适用性广泛(wide applicability)</li><li>可扩展(scalability)</li><li>高性能(high performance)</li><li>高可用(high availability)</li><li>类似数据库</li><li>提供简单的数据模型</li><li>数据都视为字符串</li></ul><h2 id=2-数据模型-data-model>2 数据模型(Data Model)</h2><ul><li>Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序 Map</li><li>Map 通过行、列、时间戳索引</li><li>Map 中的每个 value 都是一个未解析的 byte 数组</li></ul><blockquote><p>A Bigtable is a sparse, distributed, persistent multi- dimensional sorted map.
The map is indexed by a row key, column key, and a timestamp;
each value in the map is an uninterpreted array of bytes.</p></blockquote><pre><code>(row:string, column:string, time:int64) -&gt; string
</code></pre><h5 id=行-rows>行(Rows)</h5><ul><li>row key 是任意字符串，最大64kb</li><li>读写都是原子操作</li><li>按字典序组织数据</li><li>每个 row 都可以动态分区，每个分区叫一个 tablet</li></ul><h5 id=列族-column-families>列族(Column Families)</h5><ul><li>Column keys 按 Column Families 进行分组</li><li>访问控制、磁盘和内存的使用统计的基本单位</li><li>数据通常是同一类型</li><li>使用之前必须先创建</li><li>不能太多，最多几百个，Column 可以无限多</li><li>column key 命名规则 <code>family:qualifier</code></li></ul><h5 id=时间戳-timestamps>时间戳(Timestamps)</h5><ul><li>每个 cell 可以保存多个版本的数据，通过 Timestamps 区分</li><li>64 bit 整数，毫秒/用户定义</li><li>倒序排列</li><li>过期策略：最近 N 个版本/最近 N 天数据</li></ul><h2 id=3-api>3 API</h2><ul><li>建立/删除 tables、column families</li><li>修改 cluster、table、column family metadata</li><li>single-row 事务，原子的 read-modify-write，不支持 across row keys 事务</li><li>允许 cell 做为计数器</li><li>允许在服务器地址空间内执行脚本 <a href=https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/sawzall-sciprog.pdf>Sawzall</a></li></ul><p>写流程</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// Open the table
</span><span class=c1></span><span class=n>Table</span> <span class=o>*</span><span class=n>T</span> <span class=o>=</span> <span class=n>OpenOrDie</span><span class=p>(</span><span class=s>&#34;/bigtable/web/webtable&#34;</span><span class=p>);</span>
<span class=c1>// Write a new anchor and delete an old anchor
</span><span class=c1></span><span class=n>RowMutation</span> <span class=nf>r1</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=s>&#34;com.cnn.www&#34;</span><span class=p>);</span>
<span class=n>r1</span><span class=p>.</span><span class=n>Set</span><span class=p>(</span><span class=s>&#34;anchor:www.c-span.org&#34;</span><span class=p>,</span> <span class=s>&#34;CNN&#34;</span><span class=p>);</span>
<span class=n>r1</span><span class=p>.</span><span class=n>Delete</span><span class=p>(</span><span class=s>&#34;anchor:www.abc.com&#34;</span><span class=p>);</span>
<span class=n>Operation</span> <span class=n>op</span><span class=p>;</span>
<span class=n>Apply</span><span class=p>(</span><span class=o>&amp;</span><span class=n>op</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>r1</span><span class=p>);</span></code></pre></div><p>读流程</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>Scanner</span> <span class=nf>scanner</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
<span class=n>ScanStream</span> <span class=o>*</span><span class=n>stream</span><span class=p>;</span>
<span class=n>stream</span> <span class=o>=</span> <span class=n>scanner</span><span class=p>.</span><span class=n>FetchColumnFamily</span><span class=p>(</span><span class=s>&#34;anchor&#34;</span><span class=p>);</span>
<span class=n>stream</span><span class=o>-&gt;</span><span class=n>SetReturnAllVersions</span><span class=p>();</span>
<span class=n>scanner</span><span class=p>.</span><span class=n>Lookup</span><span class=p>(</span><span class=s>&#34;com.cnn.www&#34;</span><span class=p>);</span>
<span class=k>for</span> <span class=p>(;</span> <span class=o>!</span><span class=n>stream</span><span class=o>-&gt;</span><span class=n>Done</span><span class=p>();</span> <span class=n>stream</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>())</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s %s %lld %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
        <span class=n>scanner</span><span class=p>.</span><span class=n>RowName</span><span class=p>(),</span>
        <span class=n>stream</span><span class=o>-&gt;</span><span class=n>ColumnName</span><span class=p>(),</span>
        <span class=n>stream</span><span class=o>-&gt;</span><span class=n>MicroTimestamp</span><span class=p>(),</span>
        <span class=n>stream</span><span class=o>-&gt;</span><span class=n>Value</span><span class=p>());</span>
<span class=p>}</span></code></pre></div><h2 id=4-构件-building-blocks>4 构件(Building Blocks)</h2><ul><li><a href=https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf>GFS</a> 存储日志和数据</li><li>内部存储数据的文件是 SSTable 格式，持久化的、排序的、不可更改的 Map</li><li>SSTable 使用块索引定位数据，索引加载到内存</li><li>高可用的、序列化的分布式锁服务组件 <a href=https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/chubby-osdi06.pdf>Chubby</a></li></ul><p>Chubby 的作用</p><ol><li>确保在任何给定的时间内最多只有一个活动的 Master</li><li>存储数据的 bootstrap 位置</li><li>查找 tablet server，并在失效时进行善后</li><li>存储 scheme 信息(每张表的 Column family)</li><li>存储访问控制列表</li></ol><h2 id=5-实现-implementation>5 实现(Implementation)</h2><ul><li>三个组件：client library、一个 master server，多个 tablet server</li><li>每个 table 包含一个 tablet 集合</li><li>每个 tablet 包含某个范围内 row 的所有数据</li></ul><p>master server</p><ul><li>分配 tablets 到 tablet server</li><li>检测 tablet server 的增减</li><li>平衡 tablet server 的负载</li><li>GFS 文件的 gc</li><li>处理 schema 变更（table、column famliy）</li></ul><p>tablet server</p><ul><li>管理一组 tablet（10 - 1000）</li><li>处理读写请求（client 不经过 master，直接与 tablet 通信）</li><li>分割过大的 tablet(100 - 200MB)</li></ul><h3 id=5-1-tablet-位置-tablet-location>5.1 Tablet 位置(Tablet Location)</h3><p>三级 B+ 树保存 tablet location</p><ul><li>root tablet 的位置存储在 Chubby</li><li>root tablet 存储 METADATA table 的所有 tablet 位置</li><li>每个 METADATA tablet 存储一组 user tablet 位置</li><li>root tablet 是 METADATA table 的第一个 tablet，永远不会分裂</li><li>METADATA table 的每一个 row key（由 tablet 标识和它的 end row 组成）存储一个 tablet 的位置</li><li>client 缓存 tablet 的位置，过期时从头开始遍历，最多需要读6次</li><li>二级信息（log，用于调试和性能分析）也存储在 METADATA table</li></ul><h3 id=5-2-tablet-分配-tablet-assignment>5.2 Tablet 分配(Tablet Assignment)</h3><ul><li>每个 tablet 一次只会分配给一个 tablet server</li><li>Master 保存所有活着的 tablet server 行踪，分配 tablet 给有足够空间的 tablet server</li><li>Chubby 跟踪 tablet server 的服务状态</li><li>tablet server 启动时创建并获取一个在 Chubby 目录上唯一命名的文件的独占锁</li><li>Master 监控这个目录来发现 tablet server</li></ul><p>Master 启动后执行的步骤</p><ol><li>在 Chubby 获取唯一的 master 锁，防止多个 master 实例</li><li>扫描 Chubby server 目录找到所有活着的 server</li><li>与活着的 server 通信发现分配了哪些 tablet</li><li>扫描 METADATA table 找到 tablet 集合，有未分配的就分配给 tablet server</li></ol><h3 id=5-3-tablet-服务-tablet-serving>5.3 Tablet 服务(Tablet Serving)</h3><p>数据持久化到 GFS 中</p><p>写流程</p><ol><li>检查格式合法、client 权限（通过 Chubby）</li><li>写入 commit log</li><li>插入 memtable</li></ol><p>读流程</p><ol><li>检查格式合法、client 权限</li><li>在 memtable 和 SSTable 的视图上合并</li></ol><h3 id=5-4-空间收缩-compactions>5.4 空间收缩(Compactions)</h3><p>minor Compation：memtable 增长到一个阈值时被冻结，转化成 SSTable 写入 GFS，创建新的 memtable</p><ul><li>降低内存使用</li><li>降低 server 挂掉时需要从日志读取数据的大小</li></ul><p>merging compaction：合并多个 SSTable 和 memtable 形成一个新的 SSTable</p><h2 id=6-优化-refinements>6 优化(Refinements)</h2><h5 id=局部性群组-locality-groups>局部性群组(Locality groups)</h5><ul><li>将多个 column famliy 组合成一个 locality group，生成单独的 SSTable，提高读取效率</li><li>频繁访问的 locality group 放入内存（METADATA）</li></ul><h5 id=压缩-compression>压缩(Compression)</h5><ul><li>client 指定一个 locality group 的 SSTable 是否压缩、压缩格式</li><li>通常采用两遍压缩，第一遍 Bentley and McIlroy’s、第二遍快速压缩算法</li></ul><h5 id=缓存提高读性能-caching-for-read-performance>缓存提高读性能(Caching for read performance)</h5><p>二级缓存策略</p><ul><li>一级扫描缓存：Tablet server 通过 SSTable 接口获取的 key-value 对</li><li>二级 Block 缓存：从 GFS 读取的 SSTable 的 Block</li></ul><h5 id=布隆过滤-bloom-filters>布隆过滤(Bloom filters)</h5><ul><li>使用 Bloom filter 查询一个 SSTable 是否包含了特定 row 和 column 的数据</li><li>使用少量内存显著减少磁盘访问次数</li></ul><h5 id=提交日志的实现-commit-log-implementation>提交日志的实现(Commit-log implementation)</h5><ul><li>如果每个 Tablet 的 commit-log 单独存储会产生大量的文件</li><li>每个 Tablet server 一个 commit-log 文件，混合多个 Tablet 的日志记录</li><li>恢复是时候首先按关键字（table、row name、log sequence number）排序，同一个 Tablet 的日志连续存放在一起</li><li>日志分割成 64MB 的段，不同的 tablet server 对段并行排序，由 master server 协同处理</li></ul><h5 id=提升tablet的恢复速度-speeding-up-tablet-recovery>提升tablet的恢复速度(Speeding up tablet recovery)</h5><ul><li>tablet 迁移时，进行两次 Minor Compaction，减少恢复时间</li></ul><h5 id=利用不变性-exploiting-immutability>利用不变性(Exploiting immutability)</h5><p>利用 SSTable 不变对系统进行简化</p><ul><li>从 SSTable 读取数据时，不必对访问操作进行同步</li><li>把永久删除转变为对 SSTable 的垃圾收集</li><li>分割 Tablet 操作非常便捷</li></ul><h2 id=7-性能评估-performance-evaluation>7 性能评估(Performance Evaluation)</h2><ul><li>测试性能和可扩展性，建立包括 N 台 tablet server 的 Bigtable 集群</li><li>tablet server、master、test client、GFS 运行在同一组机器</li><li>测试随机读、从内存随机读、随机写、序列读、序列写、扫描</li></ul><h5 id=单个-tablet-服务器的性能-single-tablet-server-performance>单个 Tablet 服务器的性能(Single tablet-server performance)</h5><ul><li>随机读的性能比其它操作慢一个数量级</li><li>内存中随机读快很多</li><li>随机和序列写操作的性能比随机读要好些</li><li>序列读的性能好于随机读</li><li>扫描的性能更高</li></ul><h5 id=性能提升-scaling>性能提升(Scaling)</h5><ul><li>tablet server 从1台增加到500台，吞吐量增长100倍</li><li>多台服务器负载不均衡会造成性能下降</li><li>随机读的性能随 tablet server 增加 提升幅度最小</li></ul><h2 id=8-实际应用-real-applications>8 实际应用(Real Applications)</h2><p>2006 年 8 月 google 有 388 个 bigtable 集群</p><h3 id=8-1-google-analytics>8.1 Google Analytics</h3><ul><li>Raw click table(200TB)，每行一个用户的会话，按时间顺序存储</li><li>Summary table(20TB)，每个站点各种预定义信息的汇总，周期运行 MapReduce 任务生成</li></ul><h3 id=8-2-google-earth>8.2 Google Earth</h3><ul><li>存储原始图像的表(70TB)，每一行代表一个独立的地理区域</li><li>索引GFS数据的表(500GB)，每秒几万个查询请求，上百个 tablet server，in-memory column family</li></ul><h3 id=8-3-个性化搜索-personalized-search>8.3 个性化搜索(Personalized Search)</h3><ul><li>每个用户 id 和一个 column name 绑定，一个单独的 column family 被用来存储各种类型的行为</li></ul><h2 id=9-经验教训-lessons>9 经验教训(Lessons)</h2><p>很多类型的错误会导致大型分布式系统受损</p><ul><li>网络中断</li><li>很多分布式协议中设想的 fail-stop</li><li>内存数据损坏</li><li>时钟偏差</li><li>机器挂起</li><li>扩展的和非对称的网络分区</li><li>其它系统的 Bug （Chubby）</li><li>GFS 配额溢出</li><li>计划内和计划外的硬件维护</li></ul><p>在彻底了解一个新特性会被如何使用之后，再决定是否添加这个新特性</p><ul><li>只实现了单行事务</li></ul><p>系统级的监控对 Bigtable 非常重要</p><ul><li>扩展 RPC，详细记录 RPC 调用的重要操作</li><li>每个 Bigtable 集群都在 Chubby 中注册，跟踪集群状态、监控大小</li></ul><p>简单的设计有价值</p><ul><li>维护和调试带来巨大好处</li><li>重新设计简单的协议</li></ul><h2 id=10-相关工作-related-work>10 相关工作(Related Work)</h2><ul><li><a href=https://www.usenix.org/legacy/event/osdi04/tech/full_papers/maccormick/maccormick.pdf>Boxwood</a>的组件与 Chubby、GFS、Bigtable 类似，但是更底层</li><li>广域网上的分布式数据存储或高级服务（分布式 Hash 表）：<a href=http://conferences.sigcomm.org/sigcomm/2001/p13-ratnasamy.pdf>CAN</a>、<a href=https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf>Chord</a>、<a href=https://people.eecs.berkeley.edu/~adj/publications/paper-files/CSD-01-1141.pdf>Tapestry</a>、<a href=https://www.cs.rice.edu/~druschel/publications/Pastry.pdf>Pastry</a></li><li>分布式 B-Tree 、分布式 Hash 表提供的 Key-value pair 方式的模型有很大的局限性</li><li>Bigtable 模型提供的组件比简单的 Key-value pair 丰富的多，它支持稀疏的、半结构化的数据</li><li>能存储海量数据的并行数据库系统：Oracle 的 <a href=https://www.oracle.com/database/technologies/rac.html>RAC</a>、IBM 的 <a href=https://pdfs.semanticscholar.org/9c08/4a56c1c625da116eca474208d9780539ceff.pdf>DB2 Parallel Edition</a></li><li>基于列存储方案在压缩和磁盘读取方面有优势：<a href=http://db.csail.mit.edu/projects/cstore/vldb.pdf>C-Store</a>、<a href="https://dl.acm.org/citation.cfm?id=223871">Sybase IQ</a>、<a href=https://en.wikipedia.org/wiki/Sensage>SenSage</a>、<a href=https://kx.com/products/database.php>KDB+</a>、<a href=https://paperhub.s3.amazonaws.com/b451cd304d5194f7ee75fe7b6e034bc2.pdf>MonetDB/X100</a>、<a href=http://www09.sigmod.org/sigmod/sigmod99/eproceedings/papers/greer.pdf>Daytona</a>、<a href=http://research.cs.wisc.edu/multifacet/papers/vldb01_pax.pdf>Ailamaki</a></li><li>memtable 和 SSTable 存储对表的更新的方法与<a href=https://www.cs.umb.edu/~poneil/lsmtree.pdf>LSM-tree</a>类似</li></ul><h2 id=11-结论-conclusions>11 结论(Conclusions)</h2><ul><li>一个分布式的结构化数据存储系统，7人年设计和实现</li><li>用户对高性能、高可用性很满意</li><li>编程接口并不常见</li><li>新特性：二级索引、多 Master 节点、跨数据中心复制的基础构件</li><li>自己设计的优势：系统极具灵活性、问题可以快速解决</li></ul><h2 id=参考资料>参考资料</h2><ol><li><a href=https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf>Bigtable: A Distributed Storage System for Structured Data</a></li><li><a href=http://blog.bizcloudsoft.com/wp-content/uploads/Google-Bigtable%E4%B8%AD%E6%96%87%E7%89%88_1.0.pdf>Bigtable中文版</a></li></ol></div></div></section></main><footer class="footer is-dark"><div class=container><div class=has-text-centered><span class="is-size-5 is-size-6-mobile has-text-grey-light">&copy; 2020 baishen | Powered by <a href=https://gohugo.io/>Hugo</a></span></div></div></footer><script type=text/javascript>function navbarToggle(){const burger=document.querySelector('.navbar-burger');const menu=document.querySelector('.navbar-menu');burger.addEventListener('click',event=>{burger.classList.toggle("is-active");menu.classList.toggle("is-active");});}
(function(){navbarToggle();console.log("Welcome to baishen.me!");})();</script></body></html>