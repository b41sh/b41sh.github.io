<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on baishen</title><link>https://baishen.me/blog/</link><description>Recent content in Blogs on baishen</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 10 Jul 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://baishen.me/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>GFS笔记</title><link>https://baishen.me/blog/2019-07-10-gfs-note/</link><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><guid>https://baishen.me/blog/2019-07-10-gfs-note/</guid><description>1 介绍(INTRODUCTION) 规模：数千台机器、数百T存储空间、数百个客户机 设计目标：性能、可伸缩性、可靠性、可用性 组件失效是常态事件 文件非常巨大 大部分修改是在文件尾部追加数据 应用程序和文件系统 API 协同设计 2 设计概述(DESIGN OVERVIEW) 2.1 设计预期(Assumptions) 组件失效是常态事件，必须有持续的监控、错误侦测、灾难冗余以及自动恢复的机制 主要存储大文件（数GB），不需要针对小文件优化 读操作 大规模的流式读取 小规模的随机读取 写操作 大规模的、顺序的、数据追加方式的写，数据一旦写入就很少修改 支持小规模的随机写，但是效率不高 支持多个客户端并行追加数据到同一个文件，文件通常使用生产者-消费者队列或多路合并 持续的高带宽比低延迟更重要 2.2 接口(Interface) 类似传统文件系统的接口，但是不严格按照POSIX实现 支持常见的文件操作，create、delete、open、close、read、write 还支持 snapshot 和 record append 2.3 架构(Architecture) 集群包含一个 Master、多个 Chunkservers，同时被多个 Clients 访问 运行在 Linux 的 user-level 进程 文件被分割成固定大小的 Chunks，创建 Chunk 时，Master 分配一个全局唯一 (globally unique)不变(immutable)的64位标识 为了可靠性，每个 Chunk 会被复制到多个 Chunkservers，默认3个 Master管理所有的文件的 metadata 命名空间(namespace) 访问控制信息(access control information) 文件到Chunk的映射(mapping from files to Chunks) Chunk的当前位置(current locations of Chunks) Chunk租约管理(Chunk lease management) 孤儿Chunk的回收(garbage collection of orphaned Chunks) Chunk 在 Chunkserver间的迁移(Chunkmigration between Chunkservers) Master 与各个 Chunkserver通过心跳(HeartBeat)周期性的通信，传输命令并收集 Chunkserver 状态信息 Client 以库的形式嵌入到客户程序中。Clients 和 Master 通信获取 metadata，数据直接从 Chunkserver 获取 Client 和 Chunkserver 都不缓存文件数据(Client 缓存 metadata) 2.</description></item></channel></rss>