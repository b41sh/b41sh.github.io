<!doctype html><html lang=zh-cn><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-143445286-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-143445286-1');</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=Percolator构建于Bigtable之上，提供跨行事务，用于处理增量数据的索引><meta name=keywords content="Distributed System,transaction,Google"><meta name=generator content="Hugo 0.55.6"><title>baishen | blog | Percolator笔记</title><link rel=stylesheet href=https://baishen.me/css/style.css><link rel=stylesheet href=https://baishen.me/css/syntax.css></head><body class="has-navbar-fixed-top page"><nav class="navbar is-fixed-top is-black"><div class=container><div class=navbar-brand><a class=navbar-item href=https://baishen.me/>baishen</a><div role=button class=navbar-burger aria-label=menu aria-expanded=false><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></div></div><div class=navbar-menu><div class=navbar-start><div class=navbar-item></div></div><div class=navbar-end><div class="navbar-item has-dropdown is-hoverable"><a class=navbar-link href=https://baishen.me/rust-note/>Rust Note</a><div class="navbar-dropdown is-hidden-touch"><a class=navbar-item href=https://baishen.me/rust-note/><strong>1</strong>. Introduction</a></div></div><div class=navbar-item><div class="field is-grouped"><p class=control><a class="button is-twitter-blue" target=_blank href=https://twitter.com/b41sh><span class="icon has-text-white"><i class="fab fa-twitter"></i></span><span>Twitter</span></a>
<a class="button is-inverted" target=_blank href=https://github.com/b41sh><span class=icon><i class="fab fa-github"></i></span><span>Github</span></a></p></div></div></div></div></div></nav><main class=main><section class="hero is-light"><div class=hero-body><div class=container><h1 class="title is-size-1 is-size-2-mobile has-text-black has-text-black-light">Percolator笔记</h1><p class="is-size-5 has-text-black-ter">2019-08-05</p><br></div></div></section><section class="section has-background-white"><div class=container><div class="content is-medium is-blog-content"><p>Google 的索引系统存储数十 PB 的数据，每天有数十亿的更新。
MapReduce 适合处理大批量的数据，处理少量更新效率较低。
Percolator 为处理增量更新而设计，处理同样数据量的文档时可以将平均时延降低 50%。</p><h2 id=1-介绍-introduction>1 介绍(Introduction)</h2><p>爬虫抓取页面之后需要一系列 MapReduce 操作来构建索引。
包括聚类排重（处理相同页面的内容，显示 PageRank 高的），构建倒排。
MapReduce 限制并行计算，计算完 PageRank 对应的 url 之后再构建倒排，不用担心 PageRank 变化。</p><p>少量页面变化时构建索引需要把全部页面处理一遍，导致更新速度过慢。
索引可以存储在 DBMS 中，通过事务更新单行数据，但是 DBMS 无法支持 Google 的数据量（分布在数千台机器的数十PB数据）。
分布式的 Bigtable 可以支持这个数据量，但是不支持跨行事务，无法保证并发更新时数据的不变性。</p><p>为增量索引更新优化的数据处理系统应该满足如下要求：</p><ul><li>可以维护一个巨大的文档仓库，同时在爬取到新页面的时候可以高效的更新</li><li>并发处理很多小的更新时需要维持不变性（事务）</li><li>跟踪哪些更新被处理了</li></ul><p>Percolator 被设计用来解决这个问题，具有如下特点：</p><ul><li>随机访问数十 PB 数据的仓库（避免全局扫描）</li><li>多台机器上的多个进程并发访问数据（高吞吐）</li><li>提供 ACID 事务支持（快照隔离级别 snapshot isolation）</li><li>提供观察者（observers），跟踪增量计算的状态</li><li>系统由一组观察者组成，级联处理数据，第一个观察者由外部进程触发</li></ul><p>Percolator 专为处理增量数据设计，不适合如下场景：</p><ul><li>不能划分为小更新的计算（排序）更适合用 MapReduce</li><li>计算没有强一致性要求，直接使用 BigTable</li><li>资源需求较少（数据量小、CPU需求少等），直接使用传统 DBMS</li></ul><p>Google 内部使用 Percolator 构建网页索引。
在爬虫运行的同时处理文档，可以将平均时延减少50%。
通过跟踪网页与它依赖的资源，在任意依赖发生变化的时候对页面重新进行处理。</p><h2 id=2-设计-design>2 设计(Design)</h2><p>Percolator 为处理大规模增量数据提供了两个主要的抽象：</p><ul><li>支持随机访问的 ACID 事务</li><li>观察者，组织增量数据的一种方式</li></ul><p>集群中的每台机器包含3部分：</p><ul><li>Percolator worker</li><li>Bigtable tablet server</li><li>GFS chunkserver</li></ul><p>观察者关联到 Percolator worker，它扫描 bigtable 有变化的列，通过 function call 在进程内调用对应的观察者。
观察者通过向 Bigtable tablet servers 发送读写RPC来执行事务。</p><p>依赖的其他服务：</p><ul><li>timestamp oracle：提供严格增长的时间戳，用于正确操作快照隔离协议</li><li>轻量级锁服务：使脏数据的通知更高效</li></ul><p>Percolator 由少量的 table 组成，每个 table 由一组包含 row 和 column 的 cell 组成。
每个 cell 包含一个值（为支持快照隔离，每个 cell 表示为一系列由时间戳索引的值）。</p><p>设计需求：</p><ul><li>运行在大规模尺度之上（at massive scales）</li><li>不需要特别低的延迟（可以简化设计）</li><li>使用懒惰（lazy）的方式处理失败事务遗留的锁</li><li>延迟可能高达十几秒（OLTP 任务无法接受）</li><li>没有中心化的事务管理，缺乏全局死锁检测（增加了事务冲突的延迟）</li></ul><h3 id=2-1-bigtable-概述-bigtable-overview>2.1 Bigtable 概述(Bigtable overview)</h3><p>Percolator 构建于 Bigtable 分布式存储系统之上</p><ul><li>多维 sorted map：key 是（row, column，timestamp）元组</li><li>提供按 row 的查找和更新</li><li>提供 row 事务，原子读写</li><li>处理 PB 级别事务，运行与大量不可靠机器之上</li><li>由一组 tablet server 组成，每个 tablet server 管理几个 tablets（连续的 key 空间）</li><li>master 协调 tablet server 的操作，迁移 tablet</li><li>tablet 存储一组 SSTable 格式的只读文件</li><li>SSTable 存储在 GFS，提供高可靠性</li><li>一组 column 可以组成一个 locality group，存储在一个 SSTable，提高 scan 效率</li></ul><p>构建于 Bigtable 之上决定了 Percolator 的整体状况</p><ul><li>数据被组织成 Bigtable 的 row 和 column，metadata 存储为特殊的 column</li><li>API 类似于 Bigtable，增加事务相关的操作</li><li>提供 Bigtable 不具备的跨行事务（multirow transactions）和观察者框架（observer framework）</li></ul><h3 id=2-2-事务-transactions>2.2 事务(Transactions)</h3><p>Percolator 通过快照隔离实现跨行跨表的事务</p><blockquote><p>Percolator provides cross-row, cross-table transactions with ACID snapshot-isolation semantics.</p></blockquote><p>以下代码展示了简化版的通过内容哈希聚类(clustering)文档的过程。
如果 <code>Commit()</code> 返回 <code>false</code>，说明事务有冲突（两个 url 同时处理），需要重试。
<code>Get()</code> 和 <code>Commit()</code> 调用是阻塞的，通过在线程池同时运行多个事务来提高并发度。</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>bool</span> <span class=nf>UpdateDocument</span><span class=p>(</span><span class=n>Document</span> <span class=n>doc</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>Transaction</span> <span class=n>t</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cluster</span><span class=p>);</span>
  <span class=n>t</span><span class=p>.</span><span class=n>Set</span><span class=p>(</span><span class=n>doc</span><span class=p>.</span><span class=n>url</span><span class=p>(),</span> <span class=s>&#34;contents&#34;</span><span class=p>,</span> <span class=s>&#34;document&#34;</span><span class=p>,</span> <span class=n>doc</span><span class=p>.</span><span class=n>contents</span><span class=p>());</span>
  <span class=kt>int</span> <span class=n>hash</span> <span class=o>=</span> <span class=n>Hash</span><span class=p>(</span><span class=n>doc</span><span class=p>.</span><span class=n>contents</span><span class=p>());</span>
  <span class=c1>// dups table maps hash → canonical URL
</span><span class=c1></span>  <span class=n>string</span> <span class=n>canonical</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>.</span><span class=n>Get</span><span class=p>(</span><span class=n>hash</span><span class=p>,</span> <span class=s>&#34;canonical-url&#34;</span><span class=p>,</span> <span class=s>&#34;dups&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>canonical</span><span class=p>))</span> <span class=p>{</span>
    <span class=c1>// No canonical yet; write myself in
</span><span class=c1></span>    <span class=n>t</span><span class=p>.</span><span class=n>Set</span><span class=p>(</span><span class=n>hash</span><span class=p>,</span> <span class=s>&#34;canonical-url&#34;</span><span class=p>,</span> <span class=s>&#34;dups&#34;</span><span class=p>,</span> <span class=n>doc</span><span class=p>.</span><span class=n>url</span><span class=p>());</span>
  <span class=p>}</span> <span class=c1>// else this document already exists, ignore new copy
</span><span class=c1></span>  <span class=k>return</span> <span class=n>t</span><span class=p>.</span><span class=n>Commit</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><h5 id=快照隔离-snapshot-isolation>快照隔离(Snapshot Isolation)</h5><ul><li>通过 Bigtable 的 timestamp 存储每个数据的多个版本（multiple versions）</li><li>防止写-写冲突（write-write conflicts），两个事务同时写一个 cell，只有一个能提交</li><li>没有实现 serializable，存在 write skew（读写冲突）</li><li>比 serializable 更好的读性能</li></ul><h5 id=锁-lock>锁(Lock)</h5><p>锁服务的需求：</p><ul><li>机器挂掉时，也不能提交有冲突的事务</li><li>高吞吐：数千台机器同时请求锁</li><li>低延迟：每个 <code>Get()</code> 都需要加锁，这个延迟需要最小化</li></ul><p>锁需要实现的功能：</p><ul><li>多副本应对故障 replicated (to survive failure)</li><li>平衡的分布数据 distributed and balanced (to handle load)</li><li>持久化 write to a persistent data store</li></ul><h5 id=bigtable-的-columns>BigTable 的 Columns</h5><p>在 BigTable 抽象五个 Columns，其中三个跟事务相关</p><table><thead><tr><th>Column</th><th>Use</th></tr></thead><tbody><tr><td>c:lock</td><td>未提交事务写，包含 primary lock 的位置</td></tr><tr><td>c:write</td><td>已提交数据，Bigtable timestamp 的数据</td></tr><tr><td>c:data</td><td>存储数据</td></tr><tr><td>c:notify</td><td>Hints：需要运行的观察者</td></tr><tr><td>c:ack_O</td><td>已运行的观察者：存储上一次成功运行的 start timestamp</td></tr></tbody></table><h5 id=写流程-write-process>写流程(Write Process)</h5><p>初始化阶段</p><ol><li>从 timestamp oracle 获取 start timestamp</li><li>调用 <code>Set()</code> 把需要写的数据缓存起来，数据由 row、column、value 组成</li><li>接着由 client 协调开始两阶段提交（prewrite、commit）</li></ol><p>prewrite 阶段，锁定所有需要写的 cell</p><ol><li>任意指定一个 cell 为 primary，其余为 secondary</li><li>检查 primary 的 write column 在 start timestamp 之后是否有数据，如果有则退出（write-write conflict）</li><li>检查 primary 的 lock column 在任意时段是否有数据，如果有则退出（另一个已提交的事务未及时释放锁，概率很低）</li><li>对 primary 的 data column 在 start timestamp 写入 value</li><li>对 primary 的 lock column 在 start timestamp 写入 primary 的 row 和 column 位置</li><li>对各个 secondary 依次执行2-5的步骤</li></ol><p>commit 阶段</p><ol><li>client 从 timestamp oracle 获取 commit timestamp</li><li>检查 primary 的 lock column 在 start timestamp 是否有数据，如果没有则退出</li><li>对 primary 的 write column 在 commit timestamp 写入 start timestamp（指向数据的指针）</li><li>对 primary 的 lock column 的数据删除，释放锁，此时事务完成提交</li><li>对 secondary 执行3、4的操作，可能会延后操作</li></ol><h5 id=读流程-read-process>读流程(Read Process)</h5><ol><li>从 timestamp oracle 获取 start timestamp</li><li>读取 row 的 lock column 在 0 到 start timestamp 之间的数据（事务快照中可见的数据）</li><li>如果存在锁，说明有其它事务在写数据，此时需要等待锁的释放</li><li>如果没有锁，读取 row 的 write column 在 0 到 start timestamp 之间的数据，拿到 data timestamp 的指针</li><li>如果指针存在，读取 row 的 data column 在 data timestamp 的数据</li></ol><h5 id=锁的清理-lock-cleanup>锁的清理(Lock Cleanup)</h5><p>如果 client 在事务进行中失败，会导致死锁。
Percolator 采用懒惰（lazy）的方式进行清理：
如果事务 A 发现事务 B 遗留的死锁，A 需要判断 B 是否失败并清除锁。</p><p>Percolator 在每个事务中指定一个 primary cell 作为同步点（synchronizing point）。
清理或提交事务需要检查 primary 的 lock，通过 Bigtable 的 row 事务保证安全。
事务 B 在提交之前需要检查自己是否还持有 lock，只有持有才可以提交。
事务 A 在清理之前检查 lock 是否存在来保证事务 A 还没有提交。</p><p>事务遇到锁的时候可以通过检查 primary lock，有两种 case ：</p><ol><li>如果 primary lock 已经被 write record 取代，事务已提交，lock 需要 roll forward</li><li>否则 rollback</li></ol><p>rollback 导致事务退出存在性能问题，因此只能清理已经死掉的 worker。
Percolator 提供一个简单的方式判断另一个事务是否存活：
运行的 worker 在 Chubby 中写入一个 token，其它 worker 通过这个 token 判断这个 worker 是否存活。
token 存在一个 wall time，worker 定期向 Chubby 更新 wall time，过期的 worker 会被清除。</p><h5 id=示例-example>示例(Example)</h5><table><thead><tr><th>key</th><th>bal:data</th><th>bal:lock</th><th>bal:write</th></tr></thead><tbody><tr><td>Bob</td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $10</td><td>5:</td><td>5:</td></tr><tr><td>Joe</td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $2</td><td>5:</td><td>5:</td></tr></tbody></table><p>初始化状态：Joe 的账户有 $2，Bob 的账户有 $10</p><table><thead><tr><th>key</th><th>bal:data</th><th>bal:lock</th><th>bal:write</th></tr></thead><tbody><tr><td>Bob</td><td>7: $3</td><td>7: I am primary</td><td>7:</td></tr><tr><td></td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $10</td><td>5:</td><td>5:</td></tr><tr><td>Joe</td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $2</td><td>5:</td><td>5:</td></tr></tbody></table><p>转账事务开始，在 Bob 账户的 lock column(primay)写入数据，同时在 data column 写入新的账户余额，start timestamp 为7</p><table><thead><tr><th>key</th><th>bal:data</th><th>bal:lock</th><th>bal:write</th></tr></thead><tbody><tr><td>Bob</td><td>7: $3</td><td>7: I am primary</td><td>7:</td></tr><tr><td></td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $10</td><td>5:</td><td>5:</td></tr><tr><td>Joe</td><td>7: $9</td><td>7: primary@Bob.bal</td><td>7:</td></tr><tr><td></td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $2</td><td>5:</td><td>5:</td></tr></tbody></table><p>在 Joe 账户的 lock column(secondary) 写入指向 primary 的指针，同时在 data column 写入新的账户余额</p><table><thead><tr><th>key</th><th>bal:data</th><th>bal:lock</th><th>bal:write</th></tr></thead><tbody><tr><td>Bob</td><td>8:</td><td>8:</td><td>8: data@7</td></tr><tr><td></td><td>7: $3</td><td>7:</td><td>7:</td></tr><tr><td></td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $10</td><td>5:</td><td>5:</td></tr><tr><td>Joe</td><td>7: $9</td><td>7: primary@Bob.bal</td><td>7:</td></tr><tr><td></td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $2</td><td>5:</td><td>5:</td></tr></tbody></table><p>进入提交点：在 Bob 账户删除 lock column 的数据，同时在 write column 写入指向 start timestamp data 的指针，
commit timestamp 为 8</p><table><thead><tr><th>key</th><th>bal:data</th><th>bal:lock</th><th>bal:write</th></tr></thead><tbody><tr><td>Bob</td><td>8:</td><td>8:</td><td>8: data@7</td></tr><tr><td></td><td>7: $3</td><td>7:</td><td>7:</td></tr><tr><td></td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $10</td><td>5:</td><td>5:</td></tr><tr><td>Joe</td><td>8:</td><td>8:</td><td>8: data@7</td></tr><tr><td></td><td>7: $9</td><td>7:</td><td>7:</td></tr><tr><td></td><td>6:</td><td>6:</td><td>6: data@5</td></tr><tr><td></td><td>5: $2</td><td>5:</td><td>5:</td></tr></tbody></table><p>完成事务，在 Joe 账户删除 lock column 的数据，同时在 write column 写入指向 start timestamp data 的指针</p><h5 id=伪代码-pseudocode>伪代码(Pseudocode)</h5><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>class</span><span class=err> </span><span class=nc>Transaction</span> <span class=p>{</span>
  <span class=k>struct</span> <span class=n>Write</span> <span class=p>{</span>
    <span class=n>Row</span> <span class=n>row</span><span class=p>;</span>
    <span class=n>Column</span> <span class=n>col</span><span class=p>;</span>
    <span class=n>string</span> <span class=n>value</span><span class=p>;</span>
  <span class=p>};</span>
  <span class=n>vector</span><span class=o>&lt;</span><span class=n>Write</span><span class=o>&gt;</span> <span class=n>writes_</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>start_ts_</span><span class=p>;</span>

  <span class=n>Transaction</span><span class=p>()</span> <span class=o>:</span> <span class=n>start_ts_</span><span class=p>(</span><span class=n>oracle</span><span class=p>.</span><span class=n>GetTimestamp</span><span class=p>())</span> <span class=p>{}</span>
  <span class=kt>void</span> <span class=n>Set</span><span class=p>(</span><span class=n>Write</span> <span class=n>w</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>writes_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
  <span class=p>}</span>
  <span class=kt>bool</span> <span class=n>Get</span><span class=p>(</span><span class=n>Row</span> <span class=n>row</span><span class=p>,</span> <span class=n>Column</span> <span class=n>c</span><span class=p>,</span> <span class=n>string</span><span class=o>*</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>bigtable</span><span class=o>::</span><span class=n>Txn</span> <span class=n>T</span> <span class=o>=</span> <span class=n>bigtable</span><span class=o>::</span><span class=n>StartRowTransaction</span><span class=p>(</span><span class=n>row</span><span class=p>);</span>
      <span class=c1>// Check for locks that signal concurrent writes.
</span><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>T</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>c</span><span class=o>+</span><span class=s>&#34;lock&#34;</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=n>start_ts_</span><span class=p>]))</span> <span class=p>{</span>
        <span class=c1>// There is a pending lock; try to clean it and wait
</span><span class=c1></span>        <span class=n>BackoffAndMaybeCleanupLock</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
        <span class=k>continue</span><span class=p>;</span>
      <span class=p>}</span>
      <span class=c1>// Find the latest write below our start timestamp.
</span><span class=c1></span>      <span class=n>latest</span> <span class=n>write</span> <span class=o>=</span> <span class=n>T</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>c</span><span class=o>+</span><span class=s>&#34;write&#34;</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=n>start_ts_</span><span class=p>]);</span>
      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>latest_write</span><span class=p>.</span><span class=n>found</span><span class=p>())</span>
        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// no data
</span><span class=c1></span>      <span class=kt>int</span> <span class=n>data_ts</span> <span class=o>=</span> <span class=n>latest_write</span><span class=p>.</span><span class=n>start_timestamp</span><span class=p>();</span>
      <span class=o>*</span><span class=n>value</span> <span class=o>=</span> <span class=n>T</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>c</span><span class=o>+</span><span class=s>&#34;data&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>data_ts</span><span class=p>,</span> <span class=n>data_ts</span><span class=p>]);</span>
      <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=c1>// Prewrite tries to lock cell w, returning false in case of conflict.
</span><span class=c1></span>  <span class=kt>bool</span> <span class=n>Prewrite</span><span class=p>(</span><span class=n>Write</span> <span class=n>w</span><span class=p>,</span> <span class=n>Write</span> <span class=n>primary</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>Column</span> <span class=n>c</span> <span class=o>=</span> <span class=n>w</span><span class=p>.</span><span class=n>col</span><span class=p>;</span>
    <span class=n>bigtable</span><span class=o>::</span><span class=n>Txn</span> <span class=n>T</span> <span class=o>=</span> <span class=n>bigtable</span><span class=o>::</span><span class=n>StartRowTransaction</span><span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>row</span><span class=p>);</span>
    <span class=c1>// Abort on writes after our start timestamp ...
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>T</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>c</span><span class=o>+</span><span class=s>&#34;write&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>start_ts_</span><span class=p>,</span> <span class=err>∞</span><span class=p>]))</span>
      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
    <span class=c1>// ... or locks at any timestamp.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>T</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>c</span><span class=o>+</span><span class=s>&#34;lock&#34;</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=err>∞</span><span class=p>]))</span>
      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>

    <span class=n>T</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>c</span><span class=o>+</span><span class=s>&#34;data&#34;</span><span class=p>,</span> <span class=n>start_ts_</span><span class=p>,</span> <span class=n>w</span><span class=p>.</span><span class=n>value</span><span class=p>);</span>
    <span class=n>T</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>c</span><span class=o>+</span><span class=s>&#34;lock&#34;</span><span class=p>,</span> <span class=n>start_ts_</span><span class=p>,</span>
      <span class=p>{</span><span class=n>primary</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>primary</span><span class=p>.</span><span class=n>col</span><span class=p>});</span> <span class=c1>// The primary’s location.
</span><span class=c1></span>    <span class=k>return</span> <span class=n>T</span><span class=p>.</span><span class=n>Commit</span><span class=p>();</span>
  <span class=p>}</span>

  <span class=kt>bool</span> <span class=n>Commit</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// The primary’s location.
</span><span class=c1></span>    <span class=n>Write</span> <span class=n>primary</span> <span class=o>=</span> <span class=n>writes_</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=n>Write</span><span class=o>&gt;</span> <span class=n>secondaries</span><span class=p>(</span><span class=n>writes_</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>writes_</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>Prewrite</span><span class=p>(</span><span class=n>primary</span><span class=p>,</span> <span class=n>primary</span><span class=p>))</span>
      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>Write</span> <span class=nl>w</span> <span class=p>:</span> <span class=n>secondaries</span><span class=p>)</span>
      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>Prewrite</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>primary</span><span class=p>))</span>
        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>commit_ts</span> <span class=o>=</span> <span class=n>oracle_</span><span class=p>.</span><span class=n>GetTimestamp</span><span class=p>();</span>
    <span class=c1>// Commit primary first.
</span><span class=c1></span>    <span class=n>Write</span> <span class=n>p</span> <span class=o>=</span> <span class=n>primary</span><span class=p>;</span>
    <span class=n>bigtable</span><span class=o>::</span><span class=n>Txn</span> <span class=n>T</span> <span class=o>=</span> <span class=n>bigtable</span><span class=o>::</span><span class=n>StartRowTransaction</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>row</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>T</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>p</span><span class=p>.</span><span class=n>col</span><span class=o>+</span><span class=s>&#34;lock&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>start_ts_</span><span class=p>,</span> <span class=n>start_ts_</span><span class=p>]))</span>
      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// aborted while working
</span><span class=c1></span>    <span class=n>T</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>p</span><span class=p>.</span><span class=n>col</span><span class=o>+</span><span class=s>&#34;write&#34;</span><span class=p>,</span> <span class=n>commit_ts</span><span class=p>,</span> <span class=n>start_ts_</span><span class=p>);</span> <span class=c1>// Pointer to data written at start_ts_.
</span><span class=c1></span>    <span class=n>T</span><span class=p>.</span><span class=n>Erase</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>p</span><span class=p>.</span><span class=n>col</span><span class=o>+</span><span class=s>&#34;lock&#34;</span><span class=p>,</span> <span class=n>commit_ts</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>T</span><span class=p>.</span><span class=n>Commit</span><span class=p>())</span>
      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// commit point
</span><span class=c1></span>    <span class=c1>// Second phase: write out write records for secondary cells.
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>Write</span> <span class=nl>w</span> <span class=p>:</span> <span class=n>secondaries</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>bigtable</span><span class=o>::</span><span class=n>Write</span><span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>w</span><span class=p>.</span><span class=n>col</span><span class=o>+</span><span class=s>&#34;write&#34;</span><span class=p>,</span> <span class=n>commit_ts</span><span class=p>,</span> <span class=n>start_ts_</span><span class=p>);</span>
      <span class=n>bigtable</span><span class=o>::</span><span class=n>Erase</span><span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>row</span><span class=p>,</span> <span class=n>w</span><span class=p>.</span><span class=n>col</span><span class=o>+</span><span class=s>&#34;lock&#34;</span><span class=p>,</span> <span class=n>commit_ts</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span> <span class=c1>// class Transaction
</span></code></pre></div><h3 id=2-3-时间戳-timestamps>2.3 时间戳(Timestamps)</h3><p>timestamp oracle 服务保证 timestamp 严格单调递增。
由于每个事务都取两次时间，必须有很好的伸缩性（scale well）。
oracle 定期分配一批 timestamp 放入内存，并持久化最大值。
重启时跳过最大值，保证时间不会倒退。
为节省 RPC，每个 Percolator worker 仅保留一个挂起的 RPC 来跨事务批量获取 timestamp。
每台 oracle 每秒可提供200万个 timestamp。</p><h3 id=2-4-通知-notifications>2.4 通知(Notifications)</h3><h5 id=观察者-observers>观察者(observers)</h5><p>每个观察者(observer)注册一个函数，绑定一组 column，Percolator 在数据有变化时调用这个函数。
Percolator 应用由一系列观察者构成，每个观察者完成一项任务。
在索引系统中，爬虫抓取文档后首先触发索引文档（解析、提取链接等），接着触发聚类，最后将文档导出。
通知类似于数据库中的触发器(triggers)或事件(events)，但不是原子操作，不保证不变性。</p><h5 id=弱通知机制-weaker-notification>弱通知机制(weaker notification)</h5><p>每个观察者附带一个 ack column，包含观察者运行的 timestamp，如果两个观察者同时启动，确认时将会发生冲突。
为了识别需要处理的 dity cell，单独维护一个 notify column，事务提交时写入，触发观察者并提交事务后删除。
为了快速扫描，将 notify column 存储在单独的 Bigtable locality group，多个线程同时随机扫描。
线程扫描之前需要从锁服务获取锁，避免扫描到相同区域导致的性能问题。
首次部署时扫描线程会聚集在一起，类似于公交系统，如果发现另一个线程也在扫描同一个区域时，重新选择位置开始扫描。</p><h3 id=2-5-讨论-discussion>2.5 讨论(Discussion)</h3><p>相比 MapReduce 需要更多的 RPC 请求，采用如下方式优化性能：</p><ol><li>修改 API，read-modify-write 合并</li><li>批量处理，合并多个请求</li><li>按照临近访问的原则，预取相邻的数据</li></ol><h2 id=3-评估-evaluation>3 评估(Evaluation)</h2><p>Percolator 的性能介于 DBMS 和 MapReduce 之间</p><h3 id=3-1-对比mapreduce-converting-from-mapreduce>3.1 对比MapReduce(Converting from MapReduce)</h3><p>基于 Percolator 的索引系统(Caffeine)抓取同样数量的文件比 MapReduce 快100倍，使用的资源多2倍。</p><p>每次更新数据量少的时候 Percolator 性能更好，数据量大的时候 MapReduce 性能更好。</p><h3 id=3-2-基准测试-microbenchmarks>3.2 基准测试(Microbenchmarks)</h3><p>Percolator 读性能较 MapReduce 略差，写性能相差较多。</p><table><thead><tr><th>-</th><th>Bigtable</th><th>Percolator</th><th>Relative</th></tr></thead><tbody><tr><td>Read/s</td><td>15513</td><td>14590</td><td>0.94</td></tr><tr><td>Write/s</td><td>31003</td><td>7232</td><td>0.23</td></tr></tbody></table><h3 id=3-3-合成负载-synthetic-workload>3.3 合成负载(Synthetic Workload)</h3><p>采用 TPC-E 测试 Percolator 的性能</p><ul><li>不是OLTP系统，不满足延迟目标</li><li>性能和资源使用的关系在几个数量级基本是线性的，从11个核到15,000个 CPU</li><li>CPU 使用率约为基准系统的 30 倍</li></ul><h2 id=4-相关工作-related-work>4 相关工作(Related Work)</h2><ul><li>批处理系统 <a href=https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf>MapReduce</a>、<a href=http://hadoop.apache.org/>Hadoop</a>、<a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2007/03/eurosys07.pdf>Dryad</a> 处理小批量的更新效率低</li><li><a href=http://www.neilconway.org/docs/nsdi2010_hop.pdf>MapReduce Online</a> 通过将处理流程改为流水线(pipeline)来优化性能</li><li><a href="https://pdfs.semanticscholar.org/08d1/2e771d811bcd0d4bc81fa3993563efbaeadb.pdf?_ga=2.16909371.344171820.1564986972-726453249.1563806464">MapReduce: A major step backwards</a> 批评 MapReduce 不支持索引</li><li><a href=http://www.iterativemapreduce.org/hpdc-camera-ready-submission.pdf>Twister</a>、<a href=https://cseweb.ucsd.edu/~dlogothetis/docs/socc10-logothetis.pdf>logothetis</a>、<a href=https://www.usenix.org/legacy/event/hotcloud10/tech/full_papers/Zaharia.pdf>Spark</a>、<a href="https://dl.acm.org/citation.cfm?id=1855554">DryadInc</a> 优化了 MapReduce</li><li>Percolator 支持事务，迭代器和二级索引，但不支持完整的 SQL</li><li>数据存储类似无共享并行数据库(shared-nothing parallel databases)，通过 RPC 通信</li><li><a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf>snapshot isolation</a> 通过扩展<a href=https://people.eecs.berkeley.edu/~brewer/cs262/concurrency-distributed-databases.pdf>MVCC</a>的两阶段提交实现</li><li>Percolator 通过牺牲并行数据库(<a href=http://www.science.smith.edu/dftwiki/images/6/6a/ComparisonOfApproachesToLargeScaleDataAnalysis.pdf>Comparison</a>)的一些灵活性和低延迟，为巨大的数据集提供足够可扩展性</li><li><a href=https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf>Dynamo</a>、<a href=https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf>Bigtable</a>、<a href=https://pdfs.semanticscholar.org/876b/e80390bcaffb9b910ed05680b2e81a37d64d.pdf>PNUTS</a> 提供高可用的数据，但没有伴随的转换机制</li><li><a href="https://pdfs.semanticscholar.org/9081/eb3e302dc76957e68b7937ab7d37a83a7d11.pdf?_ga=2.12863285.344171820.1564986972-726453249.1563806464">Sinfonia</a>、<a href=http://www.sosp2007.org/papers/sosp064-aguilera.pdf>Sinfonia2</a> 扩展了分布式存储系统，提供了强大的一致性</li><li><a href=http://www.globule.org/publi/CSTWAC_ircs53.pdf>CloudTPS</a> 也在分布式存储系统之上构建符合 ACID 标准的数据存储</li><li><a href="https://pdfs.semanticscholar.org/2226/56f0adc032ceb77c93b3ed44b2a78de812ce.pdf?_ga=2.219955355.344171820.1564986972-726453249.1563806464">ElasTraS</a> 是一个交易数据存储，其架构类似于Percolator</li></ul><h2 id=5-结论与未来工作-conclusion-and-future-work>5 结论与未来工作(Conclusion and Future Work)</h2><p>优化分布式系统带来的开销</p><h2 id=参考资料>参考资料</h2><ol><li><a href=https://ai.google/research/pubs/pub36726.pdf>Large-scale Incremental Processing Using Distributed Transactions and Notifications</a></li><li><a href=https://github.com/ngaut/builddatabase/tree/master/percolator>Google Percolator 的事务模型</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5Mjk3NDUyNA==&amp;mid=2247483746&amp;idx=1&amp;sn=8c712a0e252c395154857af4aa76c317&amp;chksm=ec787bb1db0ff2a745bc9acb6ac06a0ccbf0ecb063ed0d0be2c8b2392297db182347b2971547&amp;scene=21#wechat_redirect">Accela推箱子 分布式系统-分布式事务（P1）</a></li></ol></div></div></section></main><footer class="footer is-dark"><div class=container><div class=has-text-centered><span class="is-size-5 is-size-6-mobile has-text-grey-light">&copy; 2019 baishen | Powered by <a href=https://gohugo.io/>Hugo</a></span></div></div></footer><script type=text/javascript>function navbarToggle(){const burger=document.querySelector('.navbar-burger');const menu=document.querySelector('.navbar-menu');burger.addEventListener('click',event=>{burger.classList.toggle("is-active");menu.classList.toggle("is-active");});}
(function(){navbarToggle();console.log("Welcome to baishen.me!");})();</script></body></html>