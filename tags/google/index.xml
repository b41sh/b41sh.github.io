<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>google on baishen</title><link>https://baishen.me/tags/google/</link><description>Recent content in google on baishen</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 13 Jul 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://baishen.me/tags/google/index.xml" rel="self" type="application/rss+xml"/><item><title>Map Reduce笔记</title><link>https://baishen.me/blog/2019-07-13-map-reduce-note/</link><pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate><guid>https://baishen.me/blog/2019-07-13-map-reduce-note/</guid><description>1 介绍(Introduction) 处理原始数据
文档抓取 Web 请求日志 处理衍生数据
倒排索引 Web 文档的图结构(graph structure) 表示 每台主机爬虫抓取数量汇总 每天被请求最多的的查询的集合 难点
并行计算 分发数据 处理错误 大多数运算包含相同的操作
输入数据应用 Map 得到一个 key/value pair 集合 在相同 key 值的 value 上应用 Reduce 操作，合并数据，得到结果 MapReduce 框架模型
处理并行计算、容错、数据分布、负载均衡 通过简单的接口来实现自动的并行化和大规模的分布式计算 2 编程模型(Programming Model) 利用一个输入 key/value pair 集合来产生一个输出的 key/value pair 集合
用户自定义的 Map 函数接收 key/value pair，输出 key/value pair 集合 MapReduce 库把所有相同 key 的 value 集合后传递给 Reduce 函数 用户自定义的 Reduce 函数合并 value 值，形成较小的 value 值集合 2.</description></item><item><title>GFS笔记</title><link>https://baishen.me/blog/2019-07-10-gfs-note/</link><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><guid>https://baishen.me/blog/2019-07-10-gfs-note/</guid><description>1 介绍(INTRODUCTION) 规模：数千台机器、数百T存储空间、数百个客户机 设计目标：性能、可伸缩性、可靠性、可用性 组件失效是常态事件 文件非常巨大 大部分修改是在文件尾部追加数据 应用程序和文件系统 API 协同设计 2 设计概述(DESIGN OVERVIEW) 2.1 设计预期(Assumptions) 组件失效是常态事件，必须有持续的监控、错误侦测、灾难冗余以及自动恢复的机制 主要存储大文件（数GB），不需要针对小文件优化 读操作 大规模的流式读取 小规模的随机读取 写操作 大规模的、顺序的、数据追加方式的写，数据一旦写入就很少修改 支持小规模的随机写，但是效率不高 支持多个客户端并行追加数据到同一个文件，文件通常使用生产者-消费者队列或多路合并 持续的高带宽比低延迟更重要 2.2 接口(Interface) 类似传统文件系统的接口，但是不严格按照POSIX实现 支持常见的文件操作，create、delete、open、close、read、write 还支持 snapshot 和 record append 2.3 架构(Architecture) 集群包含一个 Master、多个 Chunkservers，同时被多个 Clients 访问 运行在 Linux 的 user-level 进程 文件被分割成固定大小的 Chunks，创建 Chunk 时，Master 分配一个全局唯一 (globally unique)不变(immutable)的64位标识 为了可靠性，每个 Chunk 会被复制到多个 Chunkservers，默认3个 Master管理所有的文件的 metadata 命名空间(namespace) 访问控制信息(access control information) 文件到Chunk的映射(mapping from files to Chunks) Chunk的当前位置(current locations of Chunks) Chunk租约管理(Chunk lease management) 孤儿Chunk的回收(garbage collection of orphaned Chunks) Chunk 在 Chunkserver间的迁移(Chunkmigration between Chunkservers) Master 与各个 Chunkserver通过心跳(HeartBeat)周期性的通信，传输命令并收集 Chunkserver 状态信息 Client 以库的形式嵌入到客户程序中。Clients 和 Master 通信获取 metadata，数据直接从 Chunkserver 获取 Client 和 Chunkserver 都不缓存文件数据(Client 缓存 metadata) 2.</description></item></channel></rss>